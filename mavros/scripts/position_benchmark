#!/usr/bin/env python
# vim:set ts=4 sw=4 et:

'''
Benchmark positional accuracy of drone localisation using either
1) Preset setpoints (define measured waypoints and leave it there)
2) External Optitrack Vicon (fly around for a duration)
3) Manual setpoints (Keyed in in terminal)

(WIP) Implement 3rd mode for 2) with automated waypoints
'''


import rospy
import time
import csv

from math import *
# from mavros.utils import *
# from mavros import setpoint as SP
from geometry_msgs.msg import PoseStamped #geometry
import numpy as np



position_validation_topic="/uav0/mavros/local_position/pose" #position given by sensor, PoseStamped format

mode = 1 # 1 or 2 or 3, based on preset setpoints or vicon
rate=10 #rosrate

# Mode 1(preset setpoints settings)
pos_array=[[0,0],[0,5],[5,0],[5,5]] # Manually iterate position throughout the array
pos_test_duration=5 # Test accuracy for x seconds at position

# Mode 2(automatic settings)
ground_truth_topic="/vrpn_client_node/BetaVroom/pose" #PoseStamped format
test_duration=2 #seconds to test acuracy for



class benchmark:

    def __init__(self):
        
        self.rate = rospy.Rate(rate)

        self.position = PoseStamped()
        rospy.Subscriber(position_validation_topic, PoseStamped , self.positioncallback)

        if mode==1 or mode==3:
            pass
        elif mode==2:
            self.truth_position = PoseStamped()
            rospy.Subscriber(ground_truth_topic, PoseStamped , self.truthcallback)
        else:
            rospy.signal_shutdown("Invalid Mode, select 1 or 2")
            

        # Save file on shutdown
        rospy.on_shutdown(self.save)

        start_time=time.time()
      
        self.trutharr=[]
        self.posarr=[]

        while not rospy.is_shutdown(): #subsequent functions below are automatically run using this while loop (inert functions)  

            print()

            if mode==1:
                for i in pos_array:
                    print("move to setpoint"+ str(i) + " and press enter")
                    inp=input()
                    while(time.time()<start_time+pos_test_duration):
                        self.trutharr.append([i[0],i[1],i[2]])
                        self.posarr.append([self.position.x,self.position.y,self.position.z])
                        print([self.truth_position.x-self.position.x,self.truth_position.y-self.position.y,self.truth_position.z-self.position.z])
                    self.compare(self.posarr,self.trutharr)
                    start_time=time.time()
                    if inp=="e":
                        rospy.signal_shutdown("Exiting measurements")

            elif mode==2:
                if(time.time()<start_time+test_duration):
                    self.trutharr.append([self.truth_position.x,self.truth_position.y,self.truth_position.z])
                    self.posarr.append([self.position.x,self.position.y,self.position.z])
                    # print([self.truth_position.x-self.position.x,self.truth_position.y-self.position.y,self.truth_position.z-self.position.z])
                else:
                    self.compare(self.posarr,self.trutharr)
                    rospy.signal_shutdown("Finished Logging Data")

            elif mode==3:
                x,y,z=input("Enter setpoint (x,y,z), e to exit").split()
                start_time=time.time()

                if inp=="e":
                    rospy.signal_shutdown("Exiting measurements")
                else:
                    while(time.time()<start_time+pos_test_duration):
                        self.trutharr.append([x,y,z])
                        self.posarr.append([self.position.x,self.position.y,self.position.z])
                
                self.compare(self.posarr,self.trutharr)
                


            # # eu_dist=(((self.follow_position.pose.position.x-self.follower_position.pose.position.x)**2) + ((self.follow_position.pose.position.y-self.follow_position.pose.position.y)**2))**0.5
            # x=(self.follow_position.pose.position.x-self.follower_position.pose.position.x)**2
            # y=(self.follow_position.pose.position.y-self.follower_position.pose.position.y)**2
            # eu_dist=sqrt(x+y)

            # # The position that will be sent to the following drone
            # posetemp = PoseStamped()

            # # Followed is within [barrier] distance of follower, publish previously acceptable distance
            # # In this case, the drone is sent to the current position it is at and the setpoint array is untouched
            # if eu_dist < barrier:
            #     rospy.loginfo("marker below safe threshold, stopping. %s", eu_dist)
            #     posetemp.pose.position.x = self.follower_position.pose.position.x #Hover on the spot
            #     posetemp.pose.position.y = self.follower_position.pose.position.y
            #     posetemp.pose.position.z = self.follower_position.pose.position.z
            #     inttimer=time.time()
            
            # # Time is less than [followlag] threshhold, start logging drone position but dont follow yet
            # # Build up the setpoint array and wait for the drone to move [followlag]seconds away
            # elif time.time() < inttimer + followlag:
            #     rospy.loginfo("waiting for marker to move away. %s", eu_dist)
            #     posetemp.pose.position.x = self.follower_position.pose.position.x #Hover on the spot
            #     posetemp.pose.position.y = self.follower_position.pose.position.y
            #     posetemp.pose.position.z = self.follower_position.pose.position.z

            #     self.xarr.append(self.follow_position.pose.position.x) #Append the current position of the followed device to the end of the setpoint array
            #     self.yarr.append(self.follow_position.pose.position.y)
            #     self.zarr.append(self.follow_position.pose.position.z)
            #     self.xarr.pop(0) #delete the most dated position at [followlag]s after sending to the follower
            #     self.yarr.pop(0)
            #     self.zarr.pop(0)

            # # Time is more than [followlag] threshhold, publishing delayed setpoints in normal operation
            # else:
            #     self.xarr.append(self.follow_position.pose.position.x) #Append the current position to the end of the list
            #     self.yarr.append(self.follow_position.pose.position.y)
            #     self.zarr.append(self.follow_position.pose.position.z)
            #     posetemp.pose.position.x = self.xarr[0]
            #     posetemp.pose.position.y = self.yarr[0]
            #     posetemp.pose.position.z = self.zarr[0]
            #     rospy.loginfo("following normally at: %s %s %s", self.xarr[0], self.yarr[0], self.zarr[0]) # For debug
            #     self.xarr.pop(0) #delete the most dated position at [followlag]s after sending to the follower
            #     self.yarr.pop(0)
            #     self.zarr.pop(0)

            #     # Compute parameters for storage
            #     self.xvel= (posetemp.pose.position.x-self.follower_position.pose.position.x)/(time.time()-self.timestamp)
            #     self.yvel= (posetemp.pose.position.y-self.follower_position.pose.position.y)/(time.time()-self.timestamp)
            #     self.zvel= (posetemp.pose.position.z-self.follower_position.pose.position.z)/(time.time()-self.timestamp)
            #     self.xerror = self.follower_position.pose.position.x-self.follow_position.pose.position.x
            #     self.yerror = self.follower_position.pose.position.y-self.follow_position.pose.position.y
            #     self.zerror = self.follower_position.pose.position.z-self.follow_position.pose.position.z
            #     self.error=sqrt(self.xerror**2 + self.yerror**2 + self.zerror**2)

            #     self.totalarr.append([self.follow_position.pose.position.x, self.follow_position.pose.position.y, self.follow_position.pose.position.z, posetemp.pose.position.x, posetemp.pose.position.y, posetemp.pose.position.z, 
            #                     self.timestamp, self.xvel, self.yvel, self.zvel, self.xerror, self.yerror, self.zerror, self.error])
            
            # # Publish setpoints
            # self.follower_pub.publish(posetemp)

            # # Update timestamp
            # self.timestamp=time.time()

            # # Update previous location(independent of setpoint)
            # self.prevx=self.follower_position.pose.position.x
            # self.prevy=self.follower_position.pose.position.y
            # self.prevz=self.follower_position.pose.position.z

            self.rate.sleep() #The loop calls rate.sleep(), which sleeps just long enough to maintain the desired rate through the loop.

    # Compare data against ground truth
    # Takes in truth and position data arrays as arguments, data=truth=[x,y,z]
    # Captures minimum difference, maximum difference, standard deviation
    def compare(self,data,truth):
        arr=np.arr()
        minx=0
        maxx=0
        miny=0
        maxy=0
        minz=0
        maxz=0
        for i in range(len(data)):
            eu=sqrt((data[i][0]-truth[i][0])**2 + (data[i][1]-truth[i][1])**2 + (data[i][2]-truth[i][2])**2)
            arr.append([data[i][0]-truth[i][0],data[i][1]-truth[i][1],data[i][2]-truth[i][2],eu])
        print(np.std(arr))
        print(minx)    

    def positioncallback(self,data): # callback invoked with the message as the first arg
        self.position = data.pose.position

    def truthcallback(self,data): # callback invoked with the message as the first arg
        self.truth_position = data.pose.position
         
    def save(self):
        pass
    #     # wtr = csv.writer(open ('out.csv', 'w'), delimiter=',', lineterminator='\n') #~/Desktop/
    #     rmse=0
    #     print(self.totalarr)
    #     for x in range(1,len(self.totalarr)): #omit first column of headers
    #         rmse+=self.totalarr[x][-1]
    #         # wtr.writerow (self.totalarr[x])
    #         # print("saving %s",x)
    #     rmse=sqrt(rmse/ (len(self.totalarr)-1))
    #     self.totalarr.append(rmse)
    #     newarr = np.array(self.totalarr)
    #     # print(newarr)

    #     # saves to home(~)
    #     print("RMSE is {}".format(rmse))
    #     np.savetxt("data.csv", newarr, delimiter=",", fmt='%s')
    #     rospy.loginfo("Data Saved")


if __name__ == '__main__':

    rospy.init_node('benchmark_position', anonymous=True)

    node = benchmark()

    rospy.spin()
     


